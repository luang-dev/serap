<?php

namespace LuangDev\Serap\Watchers;

use Illuminate\Contracts\Debug\ExceptionHandler;
use Illuminate\Support\Facades\Context;
use Throwable;

class ExceptionWatcher
{
    /**
     * Handle the exception by getting the fingerprint of the exception
     * and format the exception data. Then add the formatted data to
     * the context.
     */
    public static function handle(): void
    {
        app()->afterResolving(ExceptionHandler::class, function ($handler) {
            $handler->reportable(function (Throwable $e) {
                $hash = self::fingerprint($e);

                $format = self::formatExceptionData($e);
                $context = [
                    'hash' => $hash,
                    ...$format,
                ];

                $exceptions = Context::get('serap_exceptions');
                $exceptions[] = $context;

                Context::add('serap_exceptions', $exceptions);
            });
        });
    }

    /**
     * Returns a unique fingerprint of the given exception.
     *
     * The fingerprint is a string that is generated by hashing the class name, file, line, and message of the exception.
     * The fingerprint can be used to identify the exception without exposing the full exception details.
     */
    protected static function fingerprint(Throwable $e): string
    {
        return md5(implode('|', [
            get_class($e),
            $e->getFile(),
            $e->getLine(),
            $e->getMessage(),
        ]));
    }

    /**
     * Format the exception data into a useful format for logging.
     *
     * The returned array will contain the following keys:
     *
     * - message: The exception message.
     * - class: The class name of the exception.
     * - file: The file where the exception occurred.
     * - line: The line number where the exception occurred.
     * - line_preview: An array of lines from the file where the exception occurred, with the error line marked.
     * - time: The timestamp when the exception occurred.
     * - trace: An array of traces, each containing the following keys:
     *   - file: The file where the trace occurred.
     *   - line: The line number where the trace occurred.
     *   - function: The function where the trace occurred.
     *   - class: The class where the trace occurred.
     */
    public static function formatExceptionData(Throwable $e, int $traceLimit = 10): array
    {
        $file = $e->getFile();
        $line = $e->getLine();

        $trace = array_slice($e->getTrace(), 0, $traceLimit);

        $linePreview = [];
        if (is_file($file) && is_readable($file)) {
            $lines = file($file, FILE_IGNORE_NEW_LINES);
            $start = max($line - 10, 0);
            $end = min($line + 10, count($lines));

            for ($i = $start; $i < $end; $i++) {
                $content = $lines[$i];

                if (($i + 1) === $line) {
                    $content .= '    // <--- error line';
                }

                $linePreview[$i + 1] = $content;
            }
        }

        return [
            'message' => $e->getMessage(),
            'class' => get_class($e),
            'file' => $file,
            'line' => $line,
            'line_preview' => $linePreview,
            'time' => now()->toISOString(),
            'trace' => array_map(
                fn ($t) => [
                    'file' => $t['file'] ?? null,
                    'line' => $t['line'] ?? null,
                    'function' => $t['function'] ?? null,
                    'class' => $t['class'] ?? null,
                ],
                $trace
            ),
        ];
    }
}
